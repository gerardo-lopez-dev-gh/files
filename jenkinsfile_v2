    pipeline {
        agent any

        parameters {
            text(name: 'CONFIG_JSON', defaultValue: '{}', description: 'JSON con la configuración del pipeline')
        }

        environment {
            DEPLOYMENT_ID = UUID.randomUUID().toString()
        }

        stages {
            stage('Preparar Repositorios') {
                steps {
                    script {
                           def config = readJSON text: params.CONFIG_JSON
                        try {
                            
                            def repos = config.repos

                            logToLogstash('INFO', "Iniciando la preparación de los repositorios", config.logstash.host, config.logstash.port)

                            

                            repos.each { repo ->
                                logToLogstash('INFO', "Iniciando la preparación del repositorio en ${repo.dir}", config.logstash.host, config.logstash.port)
                                cloneOrUpdateRepo(repo.dir, repo.url, config.logstash.host, config.logstash.port)
                                logToLogstash('INFO', "Repositorio ${repo.dir} preparado con éxito.", config.logstash.host, config.logstash.port)
                            }

                            
                            logToLogstash('INFO', "Preparación de los repositorios completada ", config.logstash.host, config.logstash.port)
                        } catch (Exception e) {
                            logToLogstash('ERROR', "Error en la preparación de repositorios: ${e.message}", config.logstash.host, config.logstash.port)
                            error("Falló la preparación de repositorios")
                        }
                    }
                }
            }

            stage('Guardar datos de repositorio sin build') {
            steps {
                script {
                    def config = readJSON text: params.CONFIG_JSON
                    def noBuildRepo = config.repos.find { !it.build }

                    if (noBuildRepo) {
                        env.NO_BUILD_REPO_DIR = noBuildRepo.dir
                        env.NO_BUILD_REPO_URL = noBuildRepo.url
                        env.NO_BUILD_REPO_USER = noBuildRepo.user
                        env.NO_BUILD_REPO_CORREO = noBuildRepo.correo
                        logToLogstash('INFO', "Datos del repositorio sin build guardados: ${noBuildRepo.dir}, ${noBuildRepo.url}", config.logstash.host, config.logstash.port)
                    } else {
                        logToLogstash('INFO', "No se encontró ningún repositorio con build=false", config.logstash.host, config.logstash.port)
                    }
                }
            }
        }
            stage('Construir Imágenes Docker') {
                steps {
                    script {
                            def deploymentData = readJSON text: params.CONFIG_JSON
                        try {
                            
                            logToLogstash('INFO', "Iniciando la construcción de imágenes Docker", deploymentData.logstash.host, deploymentData.logstash.port)
                        
                        

                            // Construir imágenes solo si "build" es true y por cada directorio de Dockerfile
                            deploymentData.repos.each { repo ->
                                if (repo.build) {
                                    repo.dockerfileDirs.each { dockerfileDir ->
                                        logToLogstash('INFO', "Construyendo imagen Docker para ${repo.dir} en ${repo.dir}/${dockerfileDir}", deploymentData.logstash.host, deploymentData.logstash.port)
                                        buildDockerImage(dockerfileDir, "${repo.dir}/${dockerfileDir}",  
                                        deploymentData.logstash.host, 
                                        deploymentData.logstash.port,
                                        deploymentData.docker.imagePrefix)
                                    }
                                } else {
                                    logToLogstash('INFO', "Saltando construcción de imagen Docker para ${repo.dir}",  deploymentData.logstash.host, deploymentData.logstash.port)
                                }
                            }

                            
                            logToLogstash('INFO', "Construcción de imágenes Docker completada",  deploymentData.logstash.host, deploymentData.logstash.port)
                        } catch (Exception e) {
                            logToLogstash('ERROR', "Error en la construcción de imágenes Docker: ${e.message}", deploymentData.logstash.host, deploymentData.logstash.port)
                            error("Falló la construcción de imágenes Docker")
                        }
                    }
                }
            }
            stage('Publicar Imágenes con Tag y Desplegar') {
                steps {
                    script {
                            // Leer el JSON desde el parámetro
                            def deploymentData = readJSON text: params.CONFIG_JSON
                        try {
                            
                            
                            // Iniciar el proceso y registrar en Logstash
                            logToLogstash('INFO', "Iniciando la generación y publicación de imágenes con tag", deploymentData.logstash.host, deploymentData.logstash.port)
                            
                            cleanGitRepo(env.NO_BUILD_REPO_DIR, deploymentData.logstash.host, deploymentData.logstash.port)
                            logToLogstash('INFO', "Repositorio ${env.NO_BUILD_REPO_DIR} limpiado, actualizando docker-compose.yml", deploymentData.logstash.host, deploymentData.logstash.port)

                            // Construir y publicar las imágenes Docker solo para los servicios especificados
                            deploymentData.repos.each { repo ->
                                   
                                if (repo.build) {

                                    def commitHash = getGitCommitHash(repo.dir, deploymentData.logstash.host, deploymentData.logstash.port)
                                    def currentDate = getCurrentDate(deploymentData.logstash.host, deploymentData.logstash.port)
                                    def docker_image_tag  = "${currentDate}_${commitHash}".replaceAll(/[^a-zA-Z0-9._-]/, '')
                                    repo.dockerfileDirs.each { dockerfileDir ->
                                        
                                        logToLogstash('INFO', "Tag de la imagen Docker generado: ${docker_image_tag}", deploymentData.logstash.host, deploymentData.logstash.port)
                                        logToLogstash('INFO', "Generando y publicando imagen Docker para ${deploymentData.docker.imagePrefix}/${dockerfileDir}", deploymentData.logstash.host, deploymentData.logstash.port)
                                        tagAndPushDockerImage(deploymentData.docker.imagePrefix, 
                                        dockerfileDir, 
                                        docker_image_tag,  
                                        deploymentData.docker.registry,
                                        deploymentData.logstash.host, 
                                        deploymentData.logstash.port)

                                          // Actualizar tags en docker-compose.yml
                                    updateDockerComposeTags( dockerfileDir,  deploymentData.docker.imagePrefix, env.NO_BUILD_REPO_DIR, deploymentData.logstash.host, deploymentData.logstash.port, docker_image_tag)
                                        

                                        
                                    }                            

                                    // Detener contenedores existentes
                                    stopExistingContainers(deploymentData.logstash.host, deploymentData.logstash.port)

                                    // Eliminar imágenes antiguas, usando los servicios específicos del repo
                                    deleteOldDockerImages(deploymentData.docker.registry, deploymentData.docker.imagePrefix, repo.dockerfileDirs, deploymentData.logstash.host, deploymentData.logstash.port, docker_image_tag)

                                } 
                            }
                           
                            

                            // Finalizar el proceso
                            logToLogstash('INFO', "Generación y publicación de imágenes completada", deploymentData.logstash.host, deploymentData.logstash.port)
                        } catch (Exception e) {
                            // Registrar cualquier error y detener el pipeline
                            logToLogstash('ERROR', "Error en la generación y publicación de imágenes: ${e.message}", deploymentData.logstash.host, deploymentData.logstash.port)
                            error("Falló la generación y publicación de imágenes")
                        }
                    }
                }
            }

            stage('Despliegue') {
                steps {
                    script {
                        // Leer el JSON desde el parámetro
                        def deploymentData = readJSON text: params.CONFIG_JSON
                        try {
                            // Iniciar despliegue
                            logToLogstash('INFO', "Iniciando el despliegue para deploymentId ${DEPLOYMENT_ID}", deploymentData.logstash.host, deploymentData.logstash.port)
                            
                            // Iterar sobre los repositorios en el JSON
                            deploymentData.repos.each { repo ->
                                if (!repo.build) {
                                    //Iniciar despliegue de nuevas imágenes
                                    startNewDeployment(repo.dir, deploymentData.logstash.host, deploymentData.logstash.port)
                                   
                                    
                                } 
                            }
                            
                            logToLogstash('INFO', "Despliegue completado para deploymentId ${deploymentData.deploymentId}", deploymentData.logstash.host, deploymentData.logstash.port)
                        } catch (Exception e) {
                            logToLogstash('ERROR', "Error en el despliegue: ${e.message}", deploymentData.logstash.host, deploymentData.logstash.port)
                            error("Falló el despliegue")
                        }
                    }
                }
            }

            stage('Commit y Push de Cambios') {
                when {
                    expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
                }
                steps {
                    script {
                        def deploymentData = readJSON text: params.CONFIG_JSON
                        try {
                            logToLogstash('INFO', "Iniciando el commit y push de cambios",  deploymentData.logstash.host, deploymentData.logstash.port)
                            commitAndPushChanges(env.NO_BUILD_REPO_DIR, env.NO_BUILD_REPO_URL, env.NO_BUILD_REPO_USER, env.NO_BUILD_REPO_CORREO, 'docker-compose.yml', "Actualizado docker-compose.yml con tag de imagen", deploymentData.logstash.host, deploymentData.logstash.port)
                            logToLogstash('INFO', "Commit y push de cambios completado",  deploymentData.logstash.host, deploymentData.logstash.port)
                        } catch (Exception e) {
                            logToLogstash('ERROR', "Error en el commit y push de cambios: ${e.message}", deploymentData.logstash.host, deploymentData.logstash.port)
                            error("Falló el commit y push de cambios")
                        }
                    }
                }
            }


        }
        post {
            failure {
                script {
                    
                    def deploymentData = readJSON text: params.CONFIG_JSON
                    logToLogstash('INFO', "Iniciando Rollback", deploymentData.logstash.host, deploymentData.logstash.port)
                    stopExistingContainers(deploymentData.logstash.host, deploymentData.logstash.port)
                    logToLogstash('ERROR', "El despliegue falló. Revirtiendo cambios en docker-compose.yml", deploymentData.logstash.host, deploymentData.logstash.port)
                    withCredentials([usernamePassword(credentialsId: 'nexus-credentials-id', usernameVariable: 'NEXUS_USERNAME', passwordVariable: 'NEXUS_PASSWORD')]) {
                        logToLogstash('INFO', "NEXUS LOGIN", deploymentData.logstash.host, deploymentData.logstash.port)
                        rollbackChanges(env.NO_BUILD_REPO_DIR, deploymentData.logstash.host, deploymentData.logstash.port)
                    }
                    
                }
            }
        }
    }
    
    

    // Funciones auxiliares
    def cloneOrUpdateRepo(repoDir, repoUrl, host, port) {
        try {
            withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                if (fileExists(repoDir)) {
                    if (fileExists("${repoDir}/.git")) {
                        dir(repoDir) {
                            sh 'git pull origin main'
                        }
                    } else {
                        sh "rm -rf ${repoDir}"
                        sh "git clone ${repoUrl} ${repoDir}"
                    }
                } else {
                    sh "git clone ${repoUrl} ${repoDir}"
                }
            }
            logToLogstash('INFO', "Repositorio ${repoDir} actualizado/clonado con éxito", host, port)
        } catch (Exception e) {
            logToLogstash('ERROR', "Error en la clonación o actualización del repositorio ${repoDir}: ${e.message}", host, port)
            throw e
        }
    }

    def buildDockerImage(service, dir, host, port, docker_image_prefix) {
        try {
            sh "docker build -t ${docker_image_prefix}-${service}:latest -f ${dir}/Dockerfile ${dir}"
            logToLogstash('INFO', "Imagen Docker para ${service} construida con éxito", host, port)
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al construir la imagen Docker para ${service}: ${e.message}", host, port)
            throw e
        }
    }

    def tagAndPushDockerImage(imagePrefix, service, docker_image_tag, registry, host, port) {
        def imageName       = "${imagePrefix}-${service}"
        def taggedImageName = "${registry}/${imageName}:${docker_image_tag}"

        try {
            sh "docker tag ${imageName}:latest ${taggedImageName}"
            logToLogstash('INFO', "Imagen Docker ${taggedImageName} etiquetada con éxito", host, port)

            withCredentials([usernamePassword(credentialsId: 'nexus-credentials-id', usernameVariable: 'NEXUS_USERNAME', passwordVariable: 'NEXUS_PASSWORD')]) {
                sh "echo $NEXUS_PASSWORD | docker login -u $NEXUS_USERNAME --password-stdin http://${registry}"
                sh "docker push ${taggedImageName}"
                logToLogstash('INFO', "Imagen Docker ${taggedImageName} publicada con éxito", host, port)
            }
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al publicar la imagen Docker ${taggedImageName}: ${e.message}", host, port)
            throw e
        }
    }

    def getGitCommitHash(repoDir, host, port) {
        try {
            def commitHash = sh(returnStdout: true, script: "cd ${repoDir} && git log -1 --pretty=format:%h").trim()
            logToLogstash('INFO', "Hash del commit obtenido: ${commitHash}", host, port)
            return commitHash
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al obtener el hash del commit: ${e.message}", host, port)
            throw e
        }
    }

    def getCurrentDate(host, port) {
        try {
            def currentDate = new Date().format('yyyyMMdd')
            logToLogstash('INFO', "Fecha actual obtenida: ${currentDate}", host, port)
            return currentDate
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al obtener la fecha actual: ${e.message}", host, port)
            throw e
        }
    }

    def updateDockerComposeTags(servicio, imagePrefix, repoDir, host, port, docker_image_tag) {
        try {
            def composeFilePath = "${repoDir}/docker-compose.yml"
            def composeFile = readFile composeFilePath
            def updatedComposeFile = composeFile.replaceAll("${imagePrefix}-${servicio}:.*", { match ->
            def serviceName = match.split(':')[0]
            return "${serviceName}:${docker_image_tag}"
            })


            // Escribe el archivo actualizado
            writeFile file: composeFilePath, text: updatedComposeFile

            // Loggea en Logstash indicando éxito
            logToLogstash('INFO', "Tags en docker-compose.yml actualizados con éxito", host, port)
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al actualizar tags en docker-compose.yml: ${e.message}", host, port)
            throw e
        }
    }



    def stopExistingContainers(host, port) {
        try {
            logToLogstash('INFO', "Deteniendo y eliminando contenedores existentes que utilizan imágenes antiguas", host, port)
            def containersToRemove = []

            def containersOutput = sh(returnStdout: true, script: """
                docker ps -a --filter 'name=docker-files-' --format '{{.ID}} {{.Image}}'
            """).trim()

            if (containersOutput) {
                containersOutput.split('\\n').each { line ->
                    def parts = line.split(' ')
                    if (parts.length >= 1) {
                        def containerId = parts[0]
                        containersToRemove << containerId
                    }
                }
            }

            if (containersToRemove) {
                containersToRemove.unique().each { containerId ->
                    sh "docker rm -f ${containerId}"
                    logToLogstash('INFO', "Contenedor ${containerId} detenido y eliminado", host, port)
                }
            } else {
                logToLogstash('INFO', "No se encontraron contenedores para detener", host, port)
            }
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al detener contenedores existentes: ${e.message}", host, port)
            throw e
        }
    }


    def startNewDeployment(repoDir, host, port) {
        try {
            sh "docker compose -f ${repoDir}/docker-compose.yml up -d"
            logToLogstash('INFO', "Nuevo despliegue iniciado con éxito", host, port)
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al iniciar el nuevo despliegue: ${e.message}", host, port)
            throw e
        }
    }

    def commitAndPushChanges(repoDir, repoUrl, name, correo,  fileName, commitMessage, host, port) {
    try {
        withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
            logToLogstash('INFO', "Commit y push de cambios en ${repoDir}", host, port)
            dir(repoDir) {
                echo "Directorio actual: ${pwd()}"
                
                sh "git add ${fileName}"
                // Configurar identidad del usuario
                sh "git config user.email ${correo}"
                sh "git config user.name ${name}"

                def remoteUrl = sh(returnStdout: true, script: 'git config --get remote.origin.url').trim()
                if (!remoteUrl) {
                    sh "git remote add origin ${repoUrl}"
                } else {
                    sh "git remote set-url origin ${repoUrl}"
                }

                

                sh "git add -A"
                sh "git commit -m '${commitMessage}' || echo 'No changes to commit'"
                
                // Incluir usuario y contraseña en la URL para autenticación
                sh "git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/${name}/${repoDir}.git main"

            }
        }

        logToLogstash('INFO', "Commit y push de cambios completado en ${fileName}", host, port)
    } catch (Exception e) {
        logToLogstash('ERROR', "Error en el commit y push de cambios: ${e.message}", host, port)
        throw e
    }
}


    def rollbackChanges(repoDir, host, port) {
        try {
            if (!fileExists(repoDir)) {
                logToLogstash('ERROR', "El directorio ${repoDir} no existe", host, port)
                return
            }

            logToLogstash('ERROR', "Revirtiendo cambios en ${repoDir} debido a fallo en despliegue", host, port)

            dir(repoDir) {
                // Capturar código de salida de 'git reset'
                def resetExitCode = sh(script: 'git reset --hard HEAD', returnStatus: true)
                if (resetExitCode != 0) {
                    logToLogstash('ERROR', "git reset falló con código: ${resetExitCode}", host, port)
                    return
                }

                // Capturar código de salida de 'git clean'
                def cleanExitCode = sh(script: 'git clean -fd', returnStatus: true)
                if (cleanExitCode != 0) {
                    logToLogstash('ERROR', "git clean falló con código: ${cleanExitCode}", host, port)
                    return
                }

                // Capturar código de salida de 'docker compose'
                def dockerExitCode = sh(script: "docker compose -f ${repoDir}/docker-compose.yml up -d", returnStatus: true)
                if (dockerExitCode != 0) {
                    logToLogstash('ERROR', "docker compose falló con código: ${dockerExitCode}", host, port)
                    return
                }
            }

            logToLogstash('INFO', "Cambios revertidos y contenedores restaurados", host, port)
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al revertir cambios: ${e.message}", host, port)
            throw e
        }
    }


    def formatTimeDifference(startTime, endTime, host, port) {
        def duration = (endTime - startTime) as long
        try {
            def hours = Math.floorDiv(duration, 1000 * 60 * 60) % 24
            def minutes = Math.floorDiv(duration, 1000 * 60) % 60
            def seconds = Math.floorDiv(duration, 1000) % 60
            def millis = duration % 1000
            def formattedTime = String.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, millis)
            return formattedTime
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al calcular la diferencia de tiempo: ${e.message}", host, port)
            throw e
        }
    }

    def cleanGitRepo(repoDir, host, port) {
        dir(repoDir) {
            sh 'git reset --hard'
            sh 'git clean -fd'
            logToLogstash('INFO', "Repositorio ${repoDir} limpiado con éxito", host, port)
        }
    }


    def deleteOldDockerImages(registry, imagePrefix, dockerfileDirs, host, port, docker_image_tag) {
        try {
            logToLogstash('INFO', "Iniciando la eliminación de imágenes antiguas", host, port)
            def imagesToDelete = []

            // Usar los servicios especificados en el array dockerfileDirs del repo
            dockerfileDirs.each { service ->
                def imagePattern = "${registry}/${imagePrefix}-${service}"

                // Obtener todas las etiquetas de la imagen, excluyendo la actual
                def imagesOutput = sh(returnStdout: true, script: """
                    docker images --format '{{.Repository}}:{{.Tag}} {{.ID}}' | grep '^${imagePattern}:' | grep -v ':${docker_image_tag}\$' || true
                """).trim()

                if (imagesOutput) {
                    imagesOutput.split('\\n').each { line ->
                        def parts = line.split(' ')
                        if (parts.length == 2) {
                            def imageId = parts[1]
                            imagesToDelete << imageId
                        }
                    }
                }
            }

            if (imagesToDelete) {
                imagesToDelete.unique().each { imageId ->
                    try {
                        sh "docker rmi -f ${imageId}"
                        logToLogstash('INFO', "Imagen ${imageId} eliminada", host, port)
                    } catch (Exception e) {
                        logToLogstash('ERROR', "Error al eliminar la imagen ${imageId}: ${e.message}", host, port)
                    }
                }
            } else {
                logToLogstash('INFO', "No hay imágenes antiguas para eliminar", host, port)
            }
        } catch (Exception e) {
            logToLogstash('ERROR', "Error al eliminar imágenes antiguas: ${e.message}", host, port)
            throw e
        }
    }


    def logToLogstash(logLevel, message, host, port) {
        def timestamp    = new Date().format("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
        def deploymentId = DEPLOYMENT_ID

        // Construir el mensaje JSON sin el envoltorio parsed_event
        def jsonMessage = [
            timestamp: timestamp,
            deployment_id: deploymentId,
            nivel: logLevel,
            mensaje: message
        ]

        // Convertir el mensaje a un string JSON
        def jsonString = groovy.json.JsonOutput.toJson(jsonMessage)

        // Escribir y enviar el mensaje
        writeFile(file: 'log_message.json', text: jsonString, encoding: 'UTF-8')
        sh "curl -X POST -H 'Content-Type: application/json; charset=UTF-8' -d @log_message.json http://${host}:${port}"
    }





        

