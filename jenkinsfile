pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = '172.21.0.3:8082' // Registro de Docker en Nexus usando el puerto 8082
        DOCKER_IMAGE_PREFIX = 'example-voting-app' // Prefijo para las imágenes Docker
        DEPLOY_LOG = 'deploy_log.txt' // Archivo para registrar las versiones desplegadas
        DOCKER_FILES_REPO = 'https://github.com/gerardo-lopez-dev-gh/docker-files.git' // Repo de Dockerfiles
        DOCKER_FILES_DIR = 'docker-files' // Directorio para el repo de Dockerfiles
    }

    stages {
        stage('Clone or Update App Repository') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                        def repoDir = 'example-voting-app'
                        def repoUrl = "https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/gerardo-lopez-dev-gh/example-voting-app.git"

                        if (fileExists(repoDir)) {
                            if (fileExists("${repoDir}/.git")) {
                                dir(repoDir) {
                                    sh 'git pull origin main'
                                }
                            } else {
                                sh "rm -rf ${repoDir}"
                                sh "git clone ${repoUrl}"
                            }
                        } else {
                            sh "git clone ${repoUrl}"
                        }
                    }
                }
            }
        }

        stage('Clone or Update Docker Files Repository') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                        def repoDir = DOCKER_FILES_DIR
                        def repoUrl = "https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/gerardo-lopez-dev-gh/docker-files.git"

                        if (fileExists(repoDir)) {
                            if (fileExists("${repoDir}/.git")) {
                                dir(repoDir) {
                                    sh 'git pull origin main'
                                }
                            } else {
                                sh "rm -rf ${repoDir}"
                                sh "git clone ${repoUrl}"
                            }
                        } else {
                            sh "git clone ${repoUrl}"
                        }
                    }
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                script {
                    dir('example-voting-app') {
                        def services = [
                            [name: 'vote', dir: 'vote'],
                            [name: 'result', dir: 'result'],
                            [name: 'worker', dir: 'worker'],
                        ]

                        services.each { service ->
                            sh "docker build -t ${DOCKER_IMAGE_PREFIX}-${service.name}:latest -f ${service.dir}/Dockerfile ${service.dir}"
                        }
                    }
                }
            }
            post {
                failure {
                    error('Error in building one of the Docker images.')
                }
            }
        }

        stage('Generate Dynamic Tag') {
            steps {
                script {
                    dir('example-voting-app') {
                        def commitHash = sh(returnStdout: true, script: 'git log -1 --pretty=format:%h').trim()
                        def currentDate = sh(returnStdout: true, script: 'date "+%Y%m%d"').trim()
                        env.DOCKER_IMAGE_TAG = "${currentDate}_${commitHash}".replaceAll(/[^a-zA-Z0-9._-]/, '')
                    }
                }
            }
        }

        stage('Push Images to Nexus') {
            steps {
                script {
                    def services = ['vote', 'result', 'worker']
                    def taggedImages = []

                    services.each { service ->
                        def imageName = "${DOCKER_IMAGE_PREFIX}-${service}"
                        def taggedImageName = "${DOCKER_REGISTRY}/${imageName}:${DOCKER_IMAGE_TAG}"
                        taggedImages << taggedImageName

                        echo "Tagging image: ${imageName}:latest as ${taggedImageName}"
                        sh "docker tag ${imageName}:latest ${taggedImageName}"
                    }

                    echo "Logging into Docker Registry at http://${DOCKER_REGISTRY}"
                    withCredentials([usernamePassword(credentialsId: 'nexus-credentials-id', usernameVariable: 'NEXUS_USERNAME', passwordVariable: 'NEXUS_PASSWORD')]) {
                        sh 'echo $NEXUS_PASSWORD | docker login -u $NEXUS_USERNAME --password-stdin http://${DOCKER_REGISTRY}'
                    }

                    taggedImages.each { taggedImageName ->
                        echo "Pushing image to registry: ${taggedImageName}"
                        sh "docker push ${taggedImageName}"
                    }

                    // Registrar la versión implementada
                    sh "echo ${DOCKER_IMAGE_TAG} >> ${DEPLOY_LOG}"
                }
            }
            post {
                failure {
                    error('Error in pushing images to Nexus.')
                }
            }
        }

        stage('Ensure Healthcheck Scripts') {
            steps {
                script {
                    sh '''
                    chmod +x example-voting-app/healthchecks/redis.sh
                    chmod +x example-voting-app/healthchecks/postgres.sh
                    '''
                }
            }
        }

        stage('Stop Existing Containers') {
            steps {
                script {
                    def containers = sh(returnStdout: true, script: "docker ps -a --filter 'name=example-' --format '{{.ID}}'").trim()
                    if (containers) {
                        containers.split('\n').each { container ->
                            sh "docker rm -f ${container}"
                        }
                    }
                }
            }
        }

        stage('Update Docker Compose') {
            steps {
                script {
                    def composeFilePath = "${DOCKER_FILES_DIR}/docker-compose.yml"
                    
                    // Leer el archivo y verificar su contenido antes y después de la actualización
                    def composeFile = readFile composeFilePath
                    echo "Contenido original de docker-compose.yml:\n${composeFile}"
                    
                    def updatedComposeFile = composeFile.replaceAll('example-voting-app-vote:[^\\s\'"]+', "example-voting-app-vote:${DOCKER_IMAGE_TAG}")
                                                        .replaceAll('example-voting-app-result:[^\\s\'"]+', "example-voting-app-result:${DOCKER_IMAGE_TAG}")
                                                        .replaceAll('example-voting-app-worker:[^\\s\'"]+', "example-voting-app-worker:${DOCKER_IMAGE_TAG}")
                    
                    echo "Contenido actualizado de docker-compose.yml:\n${updatedComposeFile}"
                    writeFile file: composeFilePath, text: updatedComposeFile
                }
            }
        }

        stage('Clean Up Old Images') {
            steps {
                script {
                    def services = ['vote', 'result', 'worker']
                    services.each { service ->
                        sh "docker images ${DOCKER_REGISTRY}/example-voting-app-${service} --format '{{.ID}}' | xargs docker rmi -f || true"
                    }
                }
            }
        }

        stage('Start New Deployment') {
            steps {
                script {
                    sh "docker compose -f ${DOCKER_FILES_DIR}/docker-compose.yml up -d"
                }
            }
        }

        stage('Commit and Push Changes') {
            when {
                expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
            }
            steps {
                script {
                    dir(DOCKER_FILES_DIR) {
                        sh "git add docker-compose.yml"
                        def commitMessage = "Updated docker-compose.yml with tag ${DOCKER_IMAGE_TAG}"
                        sh "git commit -m '${commitMessage}'"
                        withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                            sh 'git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/gerardo-lopez-dev-gh/docker-files.git main'
                        }
                    }
                }
            }
        }
    }
    post {
        failure {
            script {
                dir(DOCKER_FILES_DIR) {
                    echo 'Deployment failed. Reverting docker-compose.yml changes...'
                    sh 'git reset --hard HEAD'
                    sh "docker compose -f docker-files/docker-compose.yml up -d"
                }
            }
        }
    }
}
