pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = '172.21.0.3:8082'
        DOCKER_IMAGE_PREFIX = 'example-voting-app'
        DEPLOY_LOG = 'deploy_log.txt'
        DOCKER_FILES_REPO = 'https://github.com/gerardo-lopez-dev-gh/docker-files.git'
        DOCKER_FILES_DIR = 'docker-files'
        APP_REPO = 'https://github.com/gerardo-lopez-dev-gh/example-voting-app.git'
        APP_DIR = 'example-voting-app'
    }

    stages {
        stage('Prepare Repositories') {
            steps {
                script {
                    cloneOrUpdateRepo(APP_DIR, APP_REPO)
                    cloneOrUpdateRepo(DOCKER_FILES_DIR, DOCKER_FILES_REPO)
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                script {
                    def services = ['vote', 'result', 'worker', 'seed-data']
                    services.each { service ->
                        buildDockerImage(service, "${APP_DIR}/${service}")
                    }
                }
            }
        }

        stage('Generate and Push Images with Tag') {
            steps {
                script {
                    def commitHash = getGitCommitHash(APP_DIR)
                    def currentDate = getCurrentDate()
                    env.DOCKER_IMAGE_TAG = "${currentDate}_${commitHash}".replaceAll(/[^a-zA-Z0-9._-]/, '')

                    def services = ['vote', 'result', 'worker', 'seed-data']
                    services.each { service ->
                        tagAndPushDockerImage(service)
                    }

                    sh "echo ${DOCKER_IMAGE_TAG} >> ${DEPLOY_LOG}"
                }
            }
        }

        stage('Deployment') {
            steps {
                script {
                    updateDockerComposeTags()
                    stopExistingContainers()
                    startNewDeployment()
                }
            }
        }

        stage('Commit and Push Changes') {
            when {
                expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
            }
            steps {
                script {
                    commitAndPushChanges(DOCKER_FILES_DIR, 'docker-compose.yml', "Updated docker-compose.yml with tag ${DOCKER_IMAGE_TAG}")
                }
            }
        }
    }

    post {
        failure {
            script {
                rollbackChanges(DOCKER_FILES_DIR)
            }
        }
    }
}

// Helper Functions
def cloneOrUpdateRepo(repoDir, repoUrl) {
    withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
        if (fileExists(repoDir)) {
            if (fileExists("${repoDir}/.git")) {
                dir(repoDir) {
                    sh 'git pull origin main'
                }
            } else {
                sh "rm -rf ${repoDir}"
                sh "git clone ${repoUrl}"
            }
        } else {
            sh "git clone ${repoUrl}"
        }
    }
}

def buildDockerImage(service, dir) {
    sh "docker build -t ${DOCKER_IMAGE_PREFIX}-${service}:latest -f ${dir}/Dockerfile ${dir}"
}

def getGitCommitHash(repoDir) {
    return sh(returnStdout: true, script: "cd ${repoDir} && git log -1 --pretty=format:%h").trim()
}

def getCurrentDate() {
    return sh(returnStdout: true, script: 'date "+%Y%m%d"').trim()
}

def tagAndPushDockerImage(service) {
    def imageName = "${DOCKER_IMAGE_PREFIX}-${service}"
    def taggedImageName = "${DOCKER_REGISTRY}/${imageName}:${DOCKER_IMAGE_TAG}"
    echo "Tagging and pushing image: ${taggedImageName}"
    
    sh "docker tag ${imageName}:latest ${taggedImageName}"
    
    withCredentials([usernamePassword(credentialsId: 'nexus-credentials-id', usernameVariable: 'NEXUS_USERNAME', passwordVariable: 'NEXUS_PASSWORD')]) {
        sh "echo $NEXUS_PASSWORD | docker login -u $NEXUS_USERNAME --password-stdin http://${DOCKER_REGISTRY}"
        sh "docker push ${taggedImageName}"
    }
}

def updateDockerComposeTags() {
    def composeFilePath = "${DOCKER_FILES_DIR}/docker-compose.yml"
    def composeFile = readFile composeFilePath
    def updatedComposeFile = composeFile.replaceAll('example-voting-app-\\w+:.*', { match ->
        def serviceName = match.split(':')[0]
        return "${serviceName}:${DOCKER_IMAGE_TAG}"
    })
    writeFile file: composeFilePath, text: updatedComposeFile
}

def stopExistingContainers() {
    def containers = sh(returnStdout: true, script: "docker ps -a --filter 'name=example-' --format '{{.ID}}'").trim()
    if (containers) {
        containers.split('\n').each { container ->
            sh "docker rm -f ${container}"
        }
    }
}

def startNewDeployment() {
    sh "docker compose -f ${DOCKER_FILES_DIR}/docker-compose.yml up -d"
}

def commitAndPushChanges(repoDir, fileName, commitMessage) {
    withCredentials([usernamePassword(credentialsId: 'github-credentials-id', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
        dir(repoDir) {
            sh "git add ${fileName}"
            sh "git commit -m '${commitMessage}' || echo 'No changes to commit'"
            sh "git push"
        }
    }
}

def rollbackChanges(repoDir) {
    dir(repoDir) {
        echo 'Deployment failed. Reverting docker-compose.yml changes...'
        sh 'git reset --hard HEAD'
        sh "docker compose -f ${repoDir}/docker-compose.yml up -d"
    }
}